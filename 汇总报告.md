# 汇总报告

## PROJECT 1

实现方式：C语言 + OPENMP优化

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
![攻击原理](https://github.com/Star-Leeee/homework-group-120/assets/139939885/fc0c0572-7639-480b-9411-7ae0eecb7c93)

攻击结果👇<br>
![攻击结果](https://github.com/Star-Leeee/homework-group-120/assets/139939885/abde4525-8fc8-49bb-afeb-6911402aafd4)
在可接受的时间与内存开销内实现了最高 ***32bit* collision of SM3**

## PROJECT 2

实现方式：C语言 + OPENMP优化

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
![实现原理](https://github.com/Star-Leeee/homework-group-120/assets/139939885/5029af33-89dc-4497-98aa-571994dcc845)<br>
从初始值出发，依次获取其迭代哈希列上的值，寻找周期为i的形似*ρ*的环，**i∈[1,∞)**，其中**H_i=H_2i**。按照此原理，多线程并行可以减少时间开销，即同时进行***N***条哈希列搜索，但***N***大于一定值后带来的线程控制开销反而会降低计算速度，又考虑到SM3的优化是面向单线程的，所以我将并行数设置为CPU线程数。

攻击结果👇<br>
![攻击结果](https://github.com/Star-Leeee/homework-group-120/assets/139939885/9695440c-c816-4964-be9e-5fc53d1482a0) <br>
在可接受的时间开销内实现了最高 ***24bit* collision of SM3**

## PROJECT 3

实现方式：C语言
 
实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
一篇详细的阐述👉[Everything you need to know about hash length extension attacks](https://www.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks)<br>
MD结构的哈希函数，当message经过padding后，再按一定***长度***迭代加密，譬如512bit，如此在***message||padding***后添加***faker***消息，得到***messa||padding||faker***，这样的结构将会发生加密faker段时，输入IV为Hash(message_padding),而这是我们可知的。需要**注意**的是，***faker***不仅仅包含我们的***faker_message***，也包含一个***fake_padding***,此***fake_padding***是由***messa||padding||faker_message***计算得到的。<br>

攻击结果👇
![攻击结果——扩展](https://github.com/Star-Leeee/homework-group-120/assets/139939885/147d1f35-0d60-4a81-8160-906b58146f4e)<br>
在随机生成的**message**后扩展了**ihateyou**

## PROJECT 4

实现方式：SIMD优化+优化IO

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

SM3主要由消息扩展与迭代压缩构成<br>
![消息扩展](https://github.com/Star-Leeee/homework-group-120/assets/139939885/c8b83aaa-6355-439d-ad48-98138f0979d6)<br>消息扩展<br>
![压缩函数](https://github.com/Star-Leeee/homework-group-120/assets/139939885/b2e0e63f-3503-444c-821f-223085e09973)<br>压缩函数<br>
具体算法描述参见[SM3密码杂凑算法](https://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf)

1. SIMD优化消息扩展过程
消息扩展具有一定并行性，利于SIMD方法优化，具体使用AVX指令实现<br>
![消息扩展SIMD](https://github.com/Star-Leeee/homework-group-120/assets/139939885/7d137ab7-7d51-4f66-a3d1-4436c5f606cf)
2. 优化迭代压缩过程IO
压缩函数的优化可以从结构调整、流程变更、常数计算等方面着手。譬如不再W′i则使用W′i=Wi⊕Wi+4代替，同时在迭代压缩过程中再计算Wi，调整压缩过程以减少中间量个数，赋值、异或等操作次数，都将优化IO与计算效率，但优化IO的提升更为明显，具体方法参考[SM3杂凑算法的软件快速实现研究](http://html.rhhz.net/tis/html/20150620.htm#outline_anchor_15)。
3. 优化结果
    |优化前|优化后|提升|
    |:----:|:----:|:----:|
    |220s|26s|88%|
   
## Project5：Impl Merkle Tree following RFC6962  

### 实现方式
根据RFC6962对于Merkle Tree的设计，实现了Merkle Tree的构建，利用***Evidence***和***Verify***实现Inclusion proof and Exclusion proof for specified element

特别的，RFC6962要求构建从Root开始递归构建二叉树  
<img width="449" alt="RFC" src="https://github.com/Star-Leeee/homework-group-120/assets/139939885/dda1d0ca-d48e-41aa-846e-eb88e8c49b32">

初始化一个二维列表用于存放我们的Merkel tree，计算树的深度和叶子节点的个数，接着计算数据哈希值并写入叶子节点；每两个子节点计算相加后的哈希值并写入父节点列表。 而对于同一层的节点可以重复调用这个function（过程），生成下一层（父节点层）Merkle树的节点；每层向上生成父节点的时候，需要讨论对于节点数为奇数的层的最后一个节点，直接写入下一层（父节点层）；节点数为偶数则正好配对完全，进行递归步骤(3)和(4)的过程，循环步骤(1)计算的树的深度，完成Merkle树的生成过程；

### 具体实现
```python
def Evidence(m,Tree):
    h = (hashlib.sha256(m.encode())).hexdigest()
    try:
        n=Tree[0].index(h)
    except:
        print("The leafnode is not in the tree")

    Depth = len(Tree)
    Evidence = []
    for d in range(0,Depth):
        if n%2==0:
            if n == len(Tree[d]) - 1:
                pass
            else:
                Evidence.append([Tree[d][n],Tree[d][n+1]])
        else:
            Evidence.append([Tree[d][n-1], Tree[d][n]])

        n = math.floor(n/2)

    Evidence.append([Tree[-1][0]])

    return Evidence

def Verify(m,Evidence,Top):
    h = (hashlib.sha256(m.encode())).hexdigest()
    if h != Evidence[0][0] and h != Evidence[0][1]:
        return False

    if Evidence[-1][0] != Top:
        return False

    Depth = len(Evidence)
    for i in range(0,Depth-1):
        node = (hashlib.sha256(Evidence[i][0].encode() + Evidence[i][1].encode())).hexdigest()
        if node != Evidence[i+1][0] and node != Evidence[i+1][1]:
            return False

    if (hashlib.sha256(Evidence[-2][0].encode() + Evidence[-2][1].encode())).hexdigest() != Evidence[-1][0]:
        return False

    return True
```
 
### 运行结果
添加十万个结点后进行InclusionProof：  
![evidence](https://github.com/Star-Leeee/homework-group-120/assets/139939885/97480e0c-f599-43e6-be63-159663c983be)

## Project9: AES / SM4 software implementation

实现了SM4

![SM4](https://github.com/Star-Leeee/homework-group-120/assets/139939885/4b33a1ba-e9fc-49d7-9b77-10fea43fae27)<br>
[SM4标准](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=7803DE42D3BC5E80B0C3E5D8E873D56A)

## Project10: report on the application of this deduce technique in Ethereum with ECDSA
### ECDSA算法描述
#### 算法概述
ECDSA即椭圆曲线数字签名算法，是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。ECDSA于1999年成为ANSI标准，并于2000年成为IEEE和NIST标准。

与普通的离散对数问题（discrete logarithm problem DLP）和大数分解问题（integer factorization problem IFP）不同，椭圆曲线离散对数问题（elliptic curve discrete logarithm problem ECDLP）没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。

椭圆曲线密码体制的安全性基于椭圆曲线离散对数问题（ECDLP）的难解性。椭圆曲线离散对数问题远难于离散对数问题，椭圆曲线密码系统的单位比特强度要远高于传统的离散对数系统。因此在使用较短的密钥的情况下，ECC可以达到于DL系统相同的安全级别。这带来的好处就是计算参数更小，密钥更短，运算速度更快，签名也更加短小。因此椭圆曲线密码尤其适用于处理能力、存储空间、带宽及功耗受限的场合。

#### 优势
1. 通过公钥推导技术，以太坊交易中包含签名和原始交易数据，但不包含公钥信息。可以在验证交易时只传输签名和原始数据，而无需传输公钥，从而减少交易数据量，节省网络带宽和存储空间。
2. 以太坊是一个高交易量的区块链网络，传统的公钥验证需要从区块链中查询相应的公钥信息，使用公钥推导技术验证方可以通过签名和原始数据来推导出签名者的公钥，无需额外的公钥查询操作，减少了交易验证的时间复杂度，同时节省了区块链访问带来的计算开销。
3. 以太坊交易中的公钥是与账户地址相关联的，公钥推导技术可以在验证交易的过程中避免公开传输公钥信息，从而提高交易的隐私性和匿名性。

## Project11: impl sm2 with RFC6979

### 实验过程
运行sm2.py文件，首先生成公私钥对，输入消息message和ID，即可对消息进行签名，验证签名是否合法

### 实验结果
![11](https://github.com/Star-Leeee/homework-group-120/assets/139939885/621796b4-a37b-4473-bb36-6b3cc34f0539)
