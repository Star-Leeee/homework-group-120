# 汇总报告

## PROJECT 1

实现方式：C语言 + OPENMP优化

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
![攻击原理](https://github.com/Star-Leeee/homework-group-120/assets/139939885/fc0c0572-7639-480b-9411-7ae0eecb7c93)

攻击结果👇<br>
![攻击结果](https://github.com/Star-Leeee/homework-group-120/assets/139939885/abde4525-8fc8-49bb-afeb-6911402aafd4)
在可接受的时间与内存开销内实现了最高 ***32bit* collision of SM3**

## PROJECT 2

实现方式：C语言 + OPENMP优化

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
![实现原理](https://github.com/Star-Leeee/homework-group-120/assets/139939885/5029af33-89dc-4497-98aa-571994dcc845)<br>
从初始值出发，依次获取其迭代哈希列上的值，寻找周期为i的形似*ρ*的环，**i∈[1,∞)**，其中**H_i=H_2i**。按照此原理，多线程并行可以减少时间开销，即同时进行***N***条哈希列搜索，但***N***大于一定值后带来的线程控制开销反而会降低计算速度，又考虑到SM3的优化是面向单线程的，所以我将并行数设置为CPU线程数。

攻击结果👇<br>
![攻击结果](https://github.com/Star-Leeee/homework-group-120/assets/139939885/9695440c-c816-4964-be9e-5fc53d1482a0) <br>
在可接受的时间开销内实现了最高 ***24bit* collision of SM3**

## PROJECT 3

实现方式：C语言
 
实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

攻击原理<br>
一篇详细的阐述👉[Everything you need to know about hash length extension attacks](https://www.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks)<br>
MD结构的哈希函数，当message经过padding后，再按一定***长度***迭代加密，譬如512bit，如此在***message||padding***后添加***faker***消息，得到***messa||padding||faker***，这样的结构将会发生加密faker段时，输入IV为Hash(message_padding),而这是我们可知的。需要**注意**的是，***faker***不仅仅包含我们的***faker_message***，也包含一个***fake_padding***,此***fake_padding***是由***messa||padding||faker_message***计算得到的。<br>

攻击结果👇
![攻击结果——扩展](https://github.com/Star-Leeee/homework-group-120/assets/139939885/147d1f35-0d60-4a81-8160-906b58146f4e)<br>
在随机生成的**message**后扩展了**ihateyou**

## PROJECT 4

实现方式：SIMD优化+优化IO

实现平台<br>
|CPU|RAM|
|---|---|
|Intel Core i7-8550U|hynix DDR4 2400Mhz 8Gib|

SM3主要由消息扩展与迭代压缩构成<br>
![消息扩展](https://github.com/Star-Leeee/homework-group-120/assets/139939885/c8b83aaa-6355-439d-ad48-98138f0979d6)<br>消息扩展<br>
![压缩函数](https://github.com/Star-Leeee/homework-group-120/assets/139939885/b2e0e63f-3503-444c-821f-223085e09973)<br>压缩函数<br>
具体算法描述参见[SM3密码杂凑算法](https://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf)

1. SIMD优化消息扩展过程
消息扩展具有一定并行性，利于SIMD方法优化，具体使用AVX指令实现<br>
![消息扩展SIMD](https://github.com/Star-Leeee/homework-group-120/assets/139939885/7d137ab7-7d51-4f66-a3d1-4436c5f606cf)
2. 优化迭代压缩过程IO
压缩函数的优化可以从结构调整、流程变更、常数计算等方面着手。譬如不再W′i则使用W′i=Wi⊕Wi+4代替，同时在迭代压缩过程中再计算Wi，调整压缩过程以减少中间量个数，赋值、异或等操作次数，都将优化IO与计算效率，但优化IO的提升更为明显，具体方法参考[SM3杂凑算法的软件快速实现研究](http://html.rhhz.net/tis/html/20150620.htm#outline_anchor_15)。
3. 优化结果
    |优化前|优化后|提升|
    |:----:|:----:|:----:|
    |220s|26s|88%|
   
## Project5：Impl Merkle Tree following RFC6962  

### 实现方式
根据RFC6962对于Merkle Tree的设计，实现了Merkle Tree的构建，利用***Evidence***和***Verify***实现Inclusion proof and Exclusion proof for specified element

特别的，RFC6962要求构建从Root开始递归构建二叉树  
<img width="449" alt="RFC" src="https://github.com/Star-Leeee/homework-group-120/assets/139939885/dda1d0ca-d48e-41aa-846e-eb88e8c49b32">

初始化一个二维列表用于存放我们的Merkel tree，计算树的深度和叶子节点的个数，接着计算数据哈希值并写入叶子节点；每两个子节点计算相加后的哈希值并写入父节点列表。 而对于同一层的节点可以重复调用这个function（过程），生成下一层（父节点层）Merkle树的节点；每层向上生成父节点的时候，需要讨论对于节点数为奇数的层的最后一个节点，直接写入下一层（父节点层）；节点数为偶数则正好配对完全，进行递归步骤(3)和(4)的过程，循环步骤(1)计算的树的深度，完成Merkle树的生成过程；

### 具体实现
```python
def Evidence(m,Tree):
    h = (hashlib.sha256(m.encode())).hexdigest()
    try:
        n=Tree[0].index(h)
    except:
        print("The leafnode is not in the tree")

    Depth = len(Tree)
    Evidence = []
    for d in range(0,Depth):
        if n%2==0:
            if n == len(Tree[d]) - 1:
                pass
            else:
                Evidence.append([Tree[d][n],Tree[d][n+1]])
        else:
            Evidence.append([Tree[d][n-1], Tree[d][n]])

        n = math.floor(n/2)

    Evidence.append([Tree[-1][0]])

    return Evidence

def Verify(m,Evidence,Top):
    h = (hashlib.sha256(m.encode())).hexdigest()
    if h != Evidence[0][0] and h != Evidence[0][1]:
        return False

    if Evidence[-1][0] != Top:
        return False

    Depth = len(Evidence)
    for i in range(0,Depth-1):
        node = (hashlib.sha256(Evidence[i][0].encode() + Evidence[i][1].encode())).hexdigest()
        if node != Evidence[i+1][0] and node != Evidence[i+1][1]:
            return False

    if (hashlib.sha256(Evidence[-2][0].encode() + Evidence[-2][1].encode())).hexdigest() != Evidence[-1][0]:
        return False

    return True
```
 
### 运行结果
添加十万个结点后进行InclusionProof：  
![evidence](https://github.com/Star-Leeee/homework-group-120/assets/139939885/97480e0c-f599-43e6-be63-159663c983be)

## Project9: AES / SM4 software implementation

实现了SM4

![SM4](https://github.com/Star-Leeee/homework-group-120/assets/139939885/4b33a1ba-e9fc-49d7-9b77-10fea43fae27)<br>
[SM4标准](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=7803DE42D3BC5E80B0C3E5D8E873D56A)
